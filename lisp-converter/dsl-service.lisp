(eval-when (:compile-toplevel :load-toplevel :execute)
  (ql:quickload '(:cl-ppcre :grpc :cl-protobufs :bordeaux-threads) :silent t))

(defpackage #:ebusta-service
  (:use #:cl)
  (:export #:start #:stop #:parse-raw-to-sexp #:parse-sexp-to-ast #:build-binary))

(in-package #:ebusta-service)

(defun get-priority (op)
  (cond ((string-equal op "NOT") 3) ((string-equal op "AND") 2) ((string-equal op "OR") 1) (t 0)))

(defun tokenize (str)
  (cl-ppcre:all-matches-as-strings "(\"[^\"]+\"|[a-zA-Z0-9_]+:|AND|OR|NOT|\\(|\\)|/|\\S+)" str))

(defun numeric-p (s) (if (cl-ppcre:scan "^[0-9]+$" s) t nil))

(defun make-field-node (field val-raw)
  (let* ((val (string-trim " \"" val-raw))
         (is-regex (cl-ppcre:scan "^/.*/$" val)))
    `(:field ,field ,(if is-regex (string-trim "/" val) val) ,@(when is-regex '(:op :regex)))))

(defun process-field (token rest)
  (let* ((field (string-right-trim ":" token))
         (first (car rest)))
    (cond 
      ((and first (cl-ppcre:scan "^\".*\"$" first))
       (values (make-field-node field (car rest)) (cdr rest)))
      (t (let (coll)
           (loop while (and (car rest) 
                            (zerop (get-priority (car rest))) 
                            (not (member (car rest) '("(" ")") :test #'string-equal)))
                 do (push (pop rest) coll))
           (let ((val (if coll (format nil "~{~A~^ ~}" (nreverse coll)) "")))
             (values (make-field-node field val) rest)))))))

(defun parse-raw-to-sexp (str)
  (let ((tokens (tokenize str)) (out nil) (stack nil))
    (loop while tokens do
      (let ((tok (pop tokens)))
        (cond
          ((> (get-priority tok) 0)
           (loop while (and stack (> (get-priority (car stack)) 0) (>= (get-priority (car stack)) (get-priority tok)))
                 do (push (pop stack) out))
           (push tok stack))
          ((string= tok "(") (push tok stack))
          ((string= tok ")")
           (loop while (and stack (string/= (car stack) "(")) do (push (pop stack) out)) (pop stack))
          ((cl-ppcre:scan "^[a-zA-Z0-9_]+:$" tok)
           (multiple-value-bind (node rem) (process-field tok tokens) (push node out) (setf tokens rem)))
          (t (push (make-field-node (if (numeric-p tok) "id" "any") tok) out)))))
    (loop while stack do (push (pop stack) out))
    (let (s-eval)
      (dolist (tok (nreverse out) (car s-eval))
        (if (and (listp tok) (eq (car tok) :field)) (push tok s-eval)
            (let ((op (string-upcase (string tok))))
              (cond ((string= op "NOT") (push `(:not ,(pop s-eval)) s-eval))
                    ((member op '("AND" "OR") :test #'string=)
                     (let* ((r (pop s-eval)) (l (pop s-eval)) (k (if (string= op "AND") :and :or)))
                       (push `(,k ,l ,r) s-eval))))))))))

(defun parse-sexp-to-ast (sexp &key request-id canonical-form)
  (let ((q (cl-protobufs.ebusta.library.v1:make-search-query)))
    (when (and sexp (listp sexp))
      (let ((h (car sexp)))
        (cond
          ((member h '(:and :or))
           (let ((n (cl-protobufs.ebusta.library.v1:make-logical-node :op (if (eq h :and) 1 2))))
             (setf (cl-protobufs.ebusta.library.v1:logical-node.nodes n) (mapcar (lambda (s) (parse-sexp-to-ast s)) (cdr sexp)))
             (setf (cl-protobufs.ebusta.library.v1:search-query.logical q) n)))
          ((eq h :not)
           (let ((n (cl-protobufs.ebusta.library.v1:make-logical-node :op 3)))
             (setf (cl-protobufs.ebusta.library.v1:logical-node.nodes n) (list (parse-sexp-to-ast (second sexp))))
             (setf (cl-protobufs.ebusta.library.v1:search-query.logical q) n)))
          ((eq h :field)
           (let ((n (cl-protobufs.ebusta.library.v1:make-filter-node :field (second sexp) :value (third sexp)
                                            :operator (if (getf (cdddr sexp) :op) 6 1))))
             (setf (cl-protobufs.ebusta.library.v1:search-query.filter q) n))))))
    (if request-id (setf (cl-protobufs.ebusta.library.v1:search-query.request-id q) request-id))
    (if canonical-form (setf (cl-protobufs.ebusta.library.v1:search-query.canonical-form q) canonical-form))
    q))

(defmethod cl-protobufs.ebusta.library.v1-rpc:convert ((req cl-protobufs.ebusta.library.v1:convert-request) rpc)
  (declare (ignore rpc))
  (let* ((raw (cl-protobufs.ebusta.library.v1:convert-request.raw-query req))
         (sexp (parse-raw-to-sexp raw)))
    (parse-sexp-to-ast sexp :request-id (format nil "req-~A" (get-universal-time)) :canonical-form (format nil "~S" sexp))))

(defun start (&key (port 50052))
  (grpc:init-grpc)
  (grpc:run-grpc-proto-server (format nil "0.0.0.0:~A" port) 'cl-protobufs.ebusta.library.v1:message-converter)
  (loop (sleep 1)))

(defun build-binary ()
  #+sbcl (sb-ext:save-lisp-and-die "dsl-converter" :executable t :toplevel (lambda () 
             (setf *standard-output* *error-output*)
             (start :port 50052))))
