# Техническая спецификация: Поисковая система Ebusta (v1.1)

## 1. Обзор архитектуры
[cite_start]Система Ebusta представляет собой микросервисную поисковую платформу, предназначенную для индексации и поиска по архивам электронных книг[cite: 326]. [cite_start]Взаимодействие между компонентами осуществляется через gRPC[cite: 409].

### Потоковый конвейер (Pipeline)
1.  [cite_start]**Web-Adapter**: Принимает внешние HTTP-запросы и передает их в оркестратор[cite: 328, 411].
2.  [cite_start]**Orchestrator**: Координирует работу микросервисов и управляет идентификаторами трассировки (`Trace-ID`)[cite: 329].
3.  [cite_start]**Message-Converter**: Преобразует сырую строку запроса в абстрактное синтаксическое дерево (AST)[cite: 329, 413].
4.  [cite_start]**Processor**: Центральный узел бизнес-логики, выбирающий стратегию поиска на основе AST[cite: 330, 415].
5.  [cite_start]**Data-Manager**: Выполняет функции прокси-сервиса для взаимодействия с OpenSearch[cite: 330, 417].
6.  [cite_start]**OpenSearch**: Движок полнотекстового поиска, выполняющий запросы по индексу `flibusta_merged_index`[cite: 369].



---

## 2. Ebusta Search DSL (v1.1)

[cite_start]DSL (Domain Specific Language) предоставляет пользователю гибкий интерфейс для управления параметрами поиска[cite: 426].

### 2.1 Лексические атомы и префиксы (Scopes)
Система поддерживает следующие префиксы для уточнения области поиска:
* [cite_start]`title:` — Поиск по названию книги[cite: 426].
* [cite_start]`author:` — Поиск по имени автора[cite: 426].
* [cite_start]`author_id:` — Поиск по внутреннему идентификатору автора[cite: 426].
* [cite_start]`desc:` — Поиск по аннотации/описанию[cite: 426].
* **`id:`** — Поиск по уникальному идентификатору документа или SHA1-хешу файла.
* **`file:`** — Поиск по конкретному имени файла (например, `743373.fb2`).
* **`container:`** — Поиск по имени ZIP-архива.

### 2.2 Логические операторы и выражения
* [cite_start]**Операторы**: `AND`, `OR`, `NOT` (регистронезависимые)[cite: 426].
* [cite_start]**Приоритет**: `NOT` > `AND` > `OR`[cite: 433].
* [cite_start]**Регулярные выражения**: Поддерживаются паттерны вида `/regex/`[cite: 426, 430].
* [cite_start]**Точные фразы**: Поиск по фразе в кавычках: `"Мастер и Маргарита"`[cite: 426].

---

## 3. Внутреннее представление: SearchQuery (AST)

[cite_start]Структура данных `SearchQuery` реализована в формате Protocol Buffers (`library.proto`)[cite: 173].

### Компоненты дерева:
* [cite_start]**FilterNode**: Листовой узел, содержащий поля `field`, `value` и `operator` (`OP_EQUALS`, `OP_CONTAINS`, `OP_REGEX`)[cite: 175].
* [cite_start]**LogicalNode**: Узел ветвления, объединяющий другие запросы через логические операции[cite: 176].
* [cite_start]**NotNode**: Узел инверсии для реализации оператора `NOT`[cite: 174, 177].



---

## 4. Интеграция с данными (OpenSearch)

### 4.1 Схема индекса
[cite_start]Индекс `flibusta_merged_index` использует строгий маппинг (`dynamic: strict`)[cite: 197].
* [cite_start]**Текстовые поля**: Поля `title` и `authors` используют анализатор `mixed_text` для поддержки русского и английского языков[cite: 198, 200].
* [cite_start]**Поля ключевых слов**: Подполя `.kw` используются для точного поиска и схлопывания дублей[cite: 198, 201].
* [cite_start]**Технические метаданные**: Объект `fileInfo` хранит `container`, `filename` и `size`[cite: 205].

### 4.2 Дедупликация и ранжирование
[cite_start]Для борьбы с дубликатами используется механизм **Collapse** по полю `title.kw`[cite: 185].
* [cite_start]В результатах поиска всегда возвращается «лучшая» версия книги (секция `inner_hits` с именем `best`), отсортированная по максимальному размеру файла (`fileInfo.size`)[cite: 185, 186].

---

## 5. Текущая реализация и стратегия развития

### 5.1 Анализ состояния (Status Quo)
[cite_start]На текущий момент компонент **Parser** (`internal/parser`) успешно разбирает строку в AST в сервисе `Message-Converter`[cite: 244]. [cite_start]Однако сервис **Processor** все еще использует упрощенную логику разбора строк через `strings.HasPrefix`[cite: 231, 233].

### 5.2 План внедрения AST Walker
[cite_start]Целью является полный переход на рекурсивный обход дерева `SearchQuery` в процессоре[cite: 249]:
1.  [cite_start]**Извлечение**: Перевод `cmd/processor/main.go` на работу с полем `query` из сообщения `UnmarshaledMessage`[cite: 247].
2.  **Маппинг**: Привязка новых префиксов (`id`, `file`, `container`) к соответствующим полям индекса OpenSearch в шаблонах.
3.  [cite_start]**Логика**: Реализация трансляции `LogicalNode` в структуру `bool query` (must, should, must_not) для OpenSearch[cite: 254].
4.  [cite_start]**Валидация**: Обеспечение возврата `meta.canonical_form` для отображения дерева разбора пользователю[cite: 434, 467].

---
*Документ актуален на: 2026-01-25*
